(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{106:function(e,t,r){"use strict";r.d(t,"a",(function(){return u})),r.d(t,"b",(function(){return b}));var a=r(0),n=r.n(a);function l(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){l(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},l=Object.keys(e);for(a=0;a<l.length;a++)r=l[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)r=l[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var p=n.a.createContext({}),c=function(e){var t=n.a.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=c(e.components);return n.a.createElement(p.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},d=n.a.forwardRef((function(e,t){var r=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(r),d=a,b=u["".concat(s,".").concat(d)]||u[d]||h[d]||l;return r?n.a.createElement(b,o(o({ref:t},p),{},{components:r})):n.a.createElement(b,o({ref:t},p))}));function b(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=r.length,s=new Array(l);s[0]=d;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var p=2;p<l;p++)s[p]=r[p];return n.a.createElement.apply(null,s)}return n.a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},108:function(e,t,r){"use strict";var a=r(0),n=r.n(a);t.a=({src:e,alt:t,title:r})=>n.a.createElement("div",{className:"imageContainer"},n.a.createElement("div",{className:"center"},n.a.createElement("img",{src:e,alt:t})),n.a.createElement("div",{className:"center"},r))},88:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return o})),r.d(t,"metadata",(function(){return i})),r.d(t,"rightToc",(function(){return p})),r.d(t,"default",(function(){return u}));var a=r(2),n=r(6),l=(r(0),r(106)),s=r(108),o={slug:"private-queries-with-apollo-server-express",title:"Private queries with Apollo Server and Express",tags:["apollo-server","expressjs","error 401","typescript","exception"],image:"https://albertcito.com/img/blog/auth-graphql.png"},i={permalink:"/blog/private-queries-with-apollo-server-express",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/blog/blog/2020-10-8-private-queries-with-apollo-server-express.mdx",source:"@site/blog/2020-10-8-private-queries-with-apollo-server-express.mdx",description:"The GraphQL Spec that defines how errors should be handled. That means Apollo Server cannot send 401 server error, each request sent http status 200. Even if you have an authenticate issue, it  will return a JSON with http status 200. My plan to handle it is to create two shemas, one private and one public.",date:"2020-10-08T04:00:00.000Z",tags:[{label:"apollo-server",permalink:"/blog/tags/apollo-server"},{label:"expressjs",permalink:"/blog/tags/expressjs"},{label:"error 401",permalink:"/blog/tags/error-401"},{label:"typescript",permalink:"/blog/tags/typescript"},{label:"exception",permalink:"/blog/tags/exception"}],title:"Private queries with Apollo Server and Express",readingTime:2.045,truncated:!0,prevItem:{title:"Package to use decorators with validatorJS",permalink:"/blog/package-decorators-validatorjs"},nextItem:{title:"Handle failed server requests with a custom exception in TypeScript",permalink:"/blog/handle-failed-server-requests-with-custom-exception-typescript"}},p=[{value:"Apollo Server middleware problem",id:"apollo-server-middleware-problem",children:[]},{value:"Create Apollo Server Schema",id:"create-apollo-server-schema",children:[]},{value:"Create Middleware",id:"create-middleware",children:[]},{value:"Add the GraphQL server and Middleware to Express",id:"add-the-graphql-server-and-middleware-to-express",children:[]}],c={rightToc:p};function u(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},c,r,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"The GraphQL Spec that defines ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"http://spec.graphql.org/draft/#sec-Errors"}),"how errors should be handled"),". That means Apollo Server cannot send 401 server error, each request sent http status 200. Even if you have an authenticate issue, it  will return a JSON with http status 200. My plan to handle it is to create two shemas, one private and one public."),Object(l.b)(s.a,{src:"/img/blog/auth-graphql.png",alt:"Apollo Server query with authenticate user",title:"Apollo Server query with authenticate user",mdxType:"Image"}),Object(l.b)("h2",{id:"apollo-server-middleware-problem"},"Apollo Server middleware problem"),Object(l.b)("p",null,"The ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://typegraphql.com/docs/middlewares.html#attaching-middleware"}),"type-graphql")," middleware will return an http status 200 with a JSON with the UNAUTHENTICATED error code."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:"{4}","{4}":!0}),"@Resolver()\nclass UserResolver {\n  @Query(() => [User])\n  @UseMiddleware(isAuth)\n  users() {\n    return User.find();\n  }\n}\n")),Object(l.b)("h2",{id:"create-apollo-server-schema"},"Create Apollo Server Schema"),Object(l.b)("p",null,"This is the private schema. The line 3 has the route for the private queries and mutations. The line 9 has the path name, it means the endpoint will be in ",Object(l.b)("inlineCode",{parentName:"p"},"locahost:4000/graphql/private"),". For the public you have to do the same, change the resolvers path and the path. In my case I have ",Object(l.b)("inlineCode",{parentName:"p"},"/graphql/private"),"for the private resolvers and ",Object(l.b)("inlineCode",{parentName:"p"},"/graphql/public")," for the public ones."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:"{3,9}","{3,9}":!0}),"const server = async (app: Express) => {\n  const apolloSchema = await buildSchema({\n    resolvers: [path.join(__dirname, '../../../graphql/private/**/*.ts')],\n    validate: false,\n  });\n  const apolloServer = new ApolloServer({ schema: apolloSchema });\n  apolloServer.applyMiddleware({\n    app,\n    path: '/graphql/private',\n  });\n};\n")),Object(l.b)("h2",{id:"create-middleware"},"Create Middleware"),Object(l.b)("p",null,"This is the middleware to block ",Object(l.b)("inlineCode",{parentName:"p"},"/graphql/private"),' from unauthenticated users. Unfortunately, the "application-level middleware" in ExpressJS ',Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/expressjs/express/blob/master/lib/router/layer.js#L111"}),"does not show")," all application information within middleware. But, at least I found a way to see the current request url."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"const isAuthMiddleware = async (req: Request, res: Response, next: NextFunction) => {\n  const url = req.params[0] ?? '';\n  if (url !== '/graphql/private') {\n    next();\n    return;\n  }\n  getUserByOauthToken(req).then((user) => {\n    Auth.setUser(user);\n    next();\n  }).catch((error) => {\n    if (error instanceof AuthenticationError) {\n      res.status(401).send({ message: error.message });\n    } else {\n      res.status(500).send({ message: error.message });\n    }\n  });\n};\n")),Object(l.b)("h2",{id:"add-the-graphql-server-and-middleware-to-express"},"Add the GraphQL server and Middleware to Express"),Object(l.b)("p",null,"This is the express app, the private and public Apollo Server was added. And the ",Object(l.b)("inlineCode",{parentName:"p"},"isAuthMiddleware")," to allow authenticated users only for the url ",Object(l.b)("inlineCode",{parentName:"p"},"graphql/private"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"const getApp = async (): Promise<Express> => {\n  const app = express();\n  app.use('*', isAuthMiddleware);\n  await privateServer(app);\n  await publicServer(app);\n  return app;\n};\n")),Object(l.b)("p",null,"Finally the solution was to create a private Apollo Server schema, only allow requests for authenticated users. That means that all queries and mutations in that schema will be private. You can see the code in my ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/albertcito/nodejs-web-typescript"}),"repo"),"."))}u.isMDXComponent=!0}}]);